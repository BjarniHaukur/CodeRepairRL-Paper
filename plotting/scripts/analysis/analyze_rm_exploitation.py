#!/usr/bin/env python3
"""
Analyze rm command usage across runs, particularly looking for exploitation patterns
where agents use rm -rf followed by git clone to get rewards.
"""

import sys
import os
import argparse
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import wandb
import pandas as pd
import numpy as np
from tqdm import tqdm
import matplotlib.pyplot as plt
import seaborn as sns

from wandb_utils import get_run, get_history
from plot_config import ENTITY, PROJECT, get_output_filename


def analyze_rm_usage_across_runs():
    """
    Analyze rm command usage across all runs to find potential exploitation.
    """
    print("="*80)
    print("Analyzing rm Command Usage Across Runs")
    print("="*80)
    
    api = wandb.Api()
    runs = api.runs(f"{ENTITY}/{PROJECT}")
    
    rm_stats = []
    
    for run in tqdm(runs, desc="Analyzing runs"):
        if run.state != "finished":
            continue
            
        try:
            # Get history summary
            history = get_history(run)
            
            # Look for rm command metrics
            rm_col = 'train/extra_kwargs/shell_cmd_rm'
            git_col = 'train/extra_kwargs/shell_cmd_git'
            
            if rm_col in history.columns:
                # Get non-null rm values
                rm_values = history[rm_col].dropna()
                git_values = history[git_col].dropna() if git_col in history.columns else pd.Series([])
                
                if len(rm_values) > 0:
                    rm_stats.append({
                        'run_id': run.id,
                        'run_name': run.name,
                        'rm_mean': rm_values.mean(),
                        'rm_max': rm_values.max(),
                        'rm_sum': rm_values.sum(),
                        'git_mean': git_values.mean() if len(git_values) > 0 else 0,
                        'git_max': git_values.max() if len(git_values) > 0 else 0,
                        'num_steps': len(history),
                        'total_runtime': run.summary.get('_runtime', 0),
                        'final_reward': history['train/reward'].dropna().iloc[-1] if 'train/reward' in history.columns else 0
                    })
        except Exception as e:
            print(f"Error processing run {run.id}: {e}")
            continue
    
    if not rm_stats:
        print("No runs with rm command data found!")
        return None
    
    # Convert to DataFrame
    df = pd.DataFrame(rm_stats)
    df = df.sort_values('rm_sum', ascending=False)
    
    print(f"\nFound {len(df)} runs with rm command data")
    print(f"\nTop 10 runs by total rm commands:")
    print(df[['run_name', 'rm_sum', 'rm_mean', 'git_mean', 'final_reward']].head(10))
    
    # Find suspicious patterns
    print("\n" + "="*60)
    print("SUSPICIOUS PATTERNS (high rm + git usage)")
    print("="*60)
    
    suspicious = df[(df['rm_mean'] > 0.1) & (df['git_mean'] > 0.1)]
    if len(suspicious) > 0:
        print(f"\nFound {len(suspicious)} runs with high rm + git usage:")
        for _, row in suspicious.iterrows():
            print(f"\n{row['run_name']} ({row['run_id']})")
            print(f"  rm commands per step: {row['rm_mean']:.3f}")
            print(f"  git commands per step: {row['git_mean']:.3f}")
            print(f"  Final reward: {row['final_reward']:.3f}")
    
    return df


def deep_dive_suspicious_run(run_id):
    """
    Deep dive into a specific run to find rm -rf + git clone patterns.
    """
    print(f"\n{'='*80}")
    print(f"Deep Dive Analysis: {run_id}")
    print(f"{'='*80}")
    
    run = get_run(ENTITY, PROJECT, run_id)
    print(f"Run: {run.name}")
    
    # Get full history
    history = get_history(run)
    
    # Look for specific patterns in the history
    rm_col = 'train/extra_kwargs/shell_cmd_rm'
    git_col = 'train/extra_kwargs/shell_cmd_git'
    reward_col = 'train/reward'
    
    if rm_col in history.columns and git_col in history.columns:
        # Find steps where both rm and git were used
        high_rm_steps = history[history[rm_col] > 0].index.tolist() if rm_col in history.columns else []
        high_git_steps = history[history[git_col] > 0].index.tolist() if git_col in history.columns else []
        
        print(f"\nSteps with rm commands: {len(high_rm_steps)}")
        print(f"Steps with git commands: {len(high_git_steps)}")
        
        # Find overlapping or nearby steps
        overlap_threshold = 5  # Within 5 steps
        suspicious_steps = []
        
        for rm_step in high_rm_steps:
            for git_step in high_git_steps:
                if abs(rm_step - git_step) <= overlap_threshold:
                    suspicious_steps.append((rm_step, git_step))
        
        print(f"\nFound {len(suspicious_steps)} potentially suspicious step pairs")
        
        if suspicious_steps:
            print("\nExample suspicious patterns:")
            for i, (rm_step, git_step) in enumerate(suspicious_steps[:5]):
                print(f"\n--- Pattern {i+1} ---")
                print(f"rm at step {rm_step}, git at step {git_step}")
                if reward_col in history.columns:
                    reward_before = history[reward_col].iloc[max(0, min(rm_step, git_step)-1)]
                    reward_after = history[reward_col].iloc[min(len(history)-1, max(rm_step, git_step)+1)]
                    print(f"Reward change: {reward_before:.3f} â†’ {reward_after:.3f}")
    
    # Try to get actual table data if available
    print("\n" + "="*60)
    print("Attempting to retrieve actual completions...")
    print("="*60)
    
    # Check for any table artifacts
    artifacts = run.logged_artifacts()
    table_artifacts = [a for a in artifacts if 'table' in a.name.lower() or 'rollout' in a.name.lower()]
    
    if table_artifacts:
        print(f"Found {len(table_artifacts)} table artifacts")
        # Download and analyze first table
        for artifact in table_artifacts[:1]:
            try:
                print(f"\nDownloading artifact: {artifact.name}")
                artifact_dir = artifact.download()
                
                # Look for parquet or csv files
                import glob
                data_files = glob.glob(os.path.join(artifact_dir, "*.parquet")) + \
                           glob.glob(os.path.join(artifact_dir, "*.csv"))
                
                if data_files:
                    print(f"Found data files: {data_files}")
                    # Load first file
                    if data_files[0].endswith('.parquet'):
                        df = pd.read_parquet(data_files[0])
                    else:
                        df = pd.read_csv(data_files[0])
                    
                    print(f"Table shape: {df.shape}")
                    print(f"Columns: {list(df.columns)}")
                    
                    if 'Completion' in df.columns:
                        # Search for rm -rf patterns
                        rm_rf_count = 0
                        for idx, row in df.iterrows():
                            completion = str(row['Completion'])
                            if 'rm -rf' in completion or 'rm -fr' in completion:
                                rm_rf_count += 1
                                if rm_rf_count <= 3:  # Show first 3 examples
                                    print(f"\n--- Example {rm_rf_count} ---")
                                    # Extract context around rm -rf
                                    rm_pos = completion.find('rm -rf')
                                    if rm_pos == -1:
                                        rm_pos = completion.find('rm -fr')
                                    
                                    context_start = max(0, rm_pos - 200)
                                    context_end = min(len(completion), rm_pos + 500)
                                    context = completion[context_start:context_end]
                                    print(f"Context: ...{context}...")
                                    
                                    # Check for git clone nearby
                                    if 'git clone' in completion[rm_pos:rm_pos+1000]:
                                        print(">>> FOUND git clone after rm -rf!")
                        
                        print(f"\nTotal rm -rf instances found: {rm_rf_count}")
                        
            except Exception as e:
                print(f"Error processing artifact: {e}")
    else:
        print("No table artifacts found for this run")


def create_visualization(df):
    """
    Create visualization of rm command usage across runs.
    """
    if df is None or len(df) == 0:
        return
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle('Analysis of rm Command Usage Across Runs', fontsize=16)
    
    # 1. Scatter plot: rm vs git usage
    ax1 = axes[0, 0]
    scatter = ax1.scatter(df['rm_mean'], df['git_mean'], 
                         c=df['final_reward'], s=100, alpha=0.6, cmap='viridis')
    ax1.set_xlabel('Average rm commands per step')
    ax1.set_ylabel('Average git commands per step')
    ax1.set_title('rm vs git Command Usage')
    plt.colorbar(scatter, ax=ax1, label='Final reward')
    
    # Add diagonal line to highlight correlation
    max_val = max(df['rm_mean'].max(), df['git_mean'].max())
    ax1.plot([0, max_val], [0, max_val], 'r--', alpha=0.5, label='Equal usage')
    ax1.legend()
    
    # 2. Bar plot: Top runs by rm usage
    ax2 = axes[0, 1]
    top_runs = df.nlargest(10, 'rm_sum')
    ax2.bar(range(len(top_runs)), top_runs['rm_sum'])
    ax2.set_xticks(range(len(top_runs)))
    ax2.set_xticklabels([name[:15] + '...' if len(name) > 15 else name 
                         for name in top_runs['run_name']], rotation=45, ha='right')
    ax2.set_ylabel('Total rm commands')
    ax2.set_title('Top 10 Runs by Total rm Commands')
    
    # 3. Correlation: rm usage vs final reward
    ax3 = axes[1, 0]
    ax3.scatter(df['rm_mean'], df['final_reward'], alpha=0.6)
    ax3.set_xlabel('Average rm commands per step')
    ax3.set_ylabel('Final reward')
    ax3.set_title('rm Usage vs Final Reward')
    
    # Add trend line
    z = np.polyfit(df['rm_mean'], df['final_reward'], 1)
    p = np.poly1d(z)
    ax3.plot(df['rm_mean'].sort_values(), p(df['rm_mean'].sort_values()), "r--", alpha=0.8)
    
    # 4. Distribution of rm usage
    ax4 = axes[1, 1]
    ax4.hist(df['rm_mean'], bins=30, edgecolor='black', alpha=0.7)
    ax4.set_xlabel('Average rm commands per step')
    ax4.set_ylabel('Number of runs')
    ax4.set_title('Distribution of rm Command Usage')
    ax4.axvline(df['rm_mean'].mean(), color='red', linestyle='--', 
                label=f'Mean: {df["rm_mean"].mean():.3f}')
    ax4.legend()
    
    plt.tight_layout()
    
    # Save plot
    output_path = get_output_filename('rm_exploitation_analysis', 'all_runs') + '.png'
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    print(f"\nPlot saved to: {output_path}")
    
    plt.show()


def main():
    """Main function."""
    parser = argparse.ArgumentParser(description='Analyze rm exploitation patterns')
    parser.add_argument('--deep-dive', type=str, help='Run ID for deep dive analysis')
    args = parser.parse_args()
    
    # First, analyze all runs
    df = analyze_rm_usage_across_runs()
    
    if df is not None:
        # Create visualization
        create_visualization(df)
        
        # If specific run requested, do deep dive
        if args.deep_dive:
            deep_dive_suspicious_run(args.deep_dive)
        else:
            # Find most suspicious run for deep dive
            suspicious = df[(df['rm_mean'] > 0.1) & (df['git_mean'] > 0.1)]
            if len(suspicious) > 0:
                top_suspicious = suspicious.iloc[0]
                print(f"\n{'='*80}")
                print(f"Performing deep dive on most suspicious run...")
                print(f"{'='*80}")
                deep_dive_suspicious_run(top_suspicious['run_id'])


if __name__ == "__main__":
    main()